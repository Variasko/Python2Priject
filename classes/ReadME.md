# Тут рассмотрим классы подробнее

---

## Основы(файл: lp1)

```python
class Dog:
    pass
```

Можем заметить, что есть три основы структуры класса
1. ключевое слово class
2. название класса Dog
3. содержание, в данном случае оно пустое

---

## Начало(файл: lp2)

```python
class Dog:
    
    name: str
    age: int
    breed: str
```

Тут добавилось три ***атрибута***
1. атрибут name (кличка)
2. атрибут age (возраст)
3. атрибут breed (порода)

***Атрибут*** - это поле для хранения информации

***Метод*** - это функция, которая находится внутри класса

Добавим ***псевдо-метод __init__***

```python
def __init__(self, name, age, breed):
    self.name = name
    self.age = age
    self.breed = breed
```

***псевдо-метод __init__*** - это функция, которая выполняется при создании объекта

Создадим объект класса Dog

```python
dog = Dog("Rex", 3, "Labrador")
```

При создании объекта класса Dog мы передаем три атрибута при вполнении этого кода для объекта dog первой вызывается именно псевдо-метод init, принимающий в себя эти параметры

Попробуем поработать атрибутами класса Dog

```python
print(dog.name) # Вывод: "Rex"
print(dog.age) # Вывод: 3
print(dog.breed) # Вывод: "Labrador"
```


Так же можно и вот так

```python
dog.age += 1

print(dog.age) #Вывод: 4
```

Мы можем, менять, удалять и добавлять атрибуты в любой момент

```python
dog.owner = "Bob"

print(dog.owner) # Вывод: "Bob"
```

### У объкта dog не было атрибута owner, поэтому он был создан без помощи псевдо-метода __init__ в ручном формате, это ***плохо*** так делать не надо!, но можно

---

## Наследование и импорт (папка lp3-5, файлы lp3, lp4, lp5)

```python
class Animal:
    
    name: str
    
    def __init__(self, name):
        self.name = name
        
    def speak(self):
        print(f"{self.name} speaks!")
```

Тут мы написали простенький ***родительский*** класс Animal (класс-родитель)

В нем есть один атрибут name, который мы будем использовать в наследовании

Напишем класс Dog, который наследует Animal

```python
class Dog(Animal):
    pass
```

Создадим объект класса Dog и вызовем метод speak

```python
class Dog(Animal):
    pass


dog = Dog("Spot")
dog.speak()
```

Заметим, что у класса Dog нет атрибута name, поэтому он был создан с помощью псевдо-метода __init__ родительского класса.

### Но что делать, если нам надо добавить псевдо-метод __init__ в ***дочернем*** классе?


Всё почти просто. Напишем в дочернем классе Dog псевдо-метод __init__:

```python
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed
```

Можем заметить, что в нашем случае псевдо-метод __init__ в классе Dog принимает помимо породы ещё и кличку, но куда она идёт?

Мы можем воспользоваться методом super() для этого.
Как бы не ***переопределяя*** родиельский псевдо-метод __init__ родительского класса, а просто перенаправив данные в него.

***Родительский класс*** - это класс от которого можно что-то наследовать

***Дочерний класс*** - это класс, который наследует, атрибуты и методы от одного или нескольких родиельских классов


В файл lp4 запишем класс Animal


```python
class Animal:
    
    name: str
    
    def __init__(self, name):
        self.name = name
```

А в файле lp5 попробуем отнаследовать от него класс Cat

```python
from lp4 import Animal

class Cat(Animal):
    
    breed: str
    age: int
    
    def __init__(self, name, breed, age):
        
        super().__init__(name)
        
        self.breed = breed
        self.age = age
```

Как можем заметить, ошибок не вылезает, и при создании объекта класса Cat мы можем передать три атрибута

---

# Задание
1. Создайте __родительский__ класс Посуда, с полями материал, размер, цвет
   1. Создайте __дочерний__ класс Тарелка, с полями тип тарелки(глубокая, плоская и тп) и цены тарелки
   2. Создайте __дочерний__ класс Кружка, с полями объём кружки(450 мл, 110 мл и тп, "мл" это единица измерения, в поле должно быть записано десетичное число без них) и цены кружки
   3. Добавьте метод, в класс кружки, для вывода её характеристик